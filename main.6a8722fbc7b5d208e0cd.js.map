{"version":3,"file":"main.6a8722fbc7b5d208e0cd.js","mappings":"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","sources":["webpack://sse-ws-chat/./src/frontend/js/websocket.js","webpack://sse-ws-chat/./src/frontend/js/templates.js","webpack://sse-ws-chat/./src/frontend/index.js","webpack://sse-ws-chat/./src/frontend/js/chat.js"],"sourcesContent":["export default class WebSocketClient {\n  constructor() {\n    const backendUrl =\n      process.env.NODE_ENV === 'production'\n        ? 'wss://sse-ws-chat.onrender.com'\n        : 'ws://localhost:7070';\n\n    this.url = backendUrl;\n    this.ws = null;\n    this.handlers = new Map();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n\n  async connect() {\n    try {\n      console.log(`Подключение к ${this.url}`);\n      this.ws = new WebSocket(this.url);\n      await this.waitForConnection();\n      this.bindEvents();\n      return true;\n    } catch (error) {\n      console.error('Ошибка подключения:', error);\n      await this.handleReconnect();\n      return false;\n    }\n  }\n\n  async handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const timeout = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n      await new Promise((resolve) => setTimeout(resolve, timeout));\n      return this.connect();\n    }\n  }\n\n  waitForConnection() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Таймаут подключения'));\n      }, 5000);\n\n      this.ws.onopen = () => {\n        clearTimeout(timeout);\n        this.reconnectAttempts = 0;\n        console.log('WebSocket соединение установлено');\n        resolve();\n      };\n\n      this.ws.onerror = (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      };\n    });\n  }\n\n  bindEvents() {\n    this.ws.onclose = () => {\n      console.log('WebSocket соединение закрыто');\n      this.handleReconnect();\n    };\n\n    this.ws.onmessage = this.handleMessage.bind(this);\n  }\n\n  on(type, callback) {\n    this.handlers.set(type, callback);\n  }\n\n  send(message) {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n\n  login(nickname) {\n    this.send({ type: 'login', nickname });\n  }\n\n  sendMessage(text) {\n    this.send({ type: 'message', text });\n  }\n\n  close() {\n    this.ws?.close();\n  }\n}\n","export function createMessageElement(from, text, timestamp, isOwn) {\n  const time = new Date(timestamp).toLocaleTimeString();\n  return `\n        <div class=\"message ${isOwn ? 'own' : 'other'}\">\n            <div class=\"message-header\">${isOwn ? 'You' : from}</div>\n            <div class=\"message-text\">${escapeHtml(text)}</div>\n            <div class=\"message-time\">${time}</div>\n        </div>\n    `;\n}\n\nexport function createUserElement(user, isCurrentUser) {\n  return `<li class=\"user ${isCurrentUser ? 'current' : ''}\">${isCurrentUser ? 'You' : escapeHtml(user)}</li>`;\n}\n\nfunction escapeHtml(text) {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n","import './css/style.css';\nimport Chat from './js/chat.js';\n\nconst chat = new Chat();\n","import WebSocketClient from './websocket.js';\nimport { createMessageElement, createUserElement } from './templates.js';\n\nexport default class Chat {\n  constructor() {\n    this.client = null;\n    this.nickname = localStorage.getItem('nickname');\n    this.messagesList = document.getElementById('messages');\n    this.usersList = document.getElementById('usersList');\n    this.messageForm = document.getElementById('messageForm');\n    this.messageInput = document.getElementById('messageInput');\n\n    this.init();\n  }\n\n  async init() {\n    try {\n      if (!this.nickname) {\n        const nickname = await this.promptNickname();\n        if (!nickname) return;\n\n        this.nickname = nickname;\n        localStorage.setItem('nickname', nickname);\n      }\n\n      await this.initWebSocket(this.nickname);\n      this.bindEvents();\n    } catch (error) {\n      console.error('Ошибка инициализации:', error);\n      localStorage.removeItem('nickname');\n      setTimeout(() => this.init(), 3000);\n    }\n  }\n\n  async promptNickname() {\n    const nickname = prompt('Введите ваш никнейм:');\n    if (!nickname?.trim()) {\n      return null;\n    }\n    return nickname.trim();\n  }\n\n  async initWebSocket(nickname) {\n    this.client = new WebSocketClient();\n    this.setupWebSocketHandlers();\n    const connected = await this.client.connect();\n\n    if (connected) {\n      this.client.login(nickname);\n    } else {\n      throw new Error('Не удалось подключиться к серверу');\n    }\n  }\n\n  setupWebSocketHandlers() {\n    this.client.on('login', this.handleLogin.bind(this));\n    this.client.on('users', this.updateUserList.bind(this));\n    this.client.on('message', this.addMessage.bind(this));\n  }\n\n  bindEvents() {\n    this.messageForm.addEventListener('submit', this.handleSubmit.bind(this));\n  }\n\n  handleSubmit(event) {\n    event.preventDefault();\n    const text = this.messageInput.value.trim();\n    if (text) {\n      this.client.sendMessage(text);\n      this.messageInput.value = '';\n    }\n  }\n\n  handleLogin(message) {\n    if (!message.success) {\n      localStorage.removeItem('nickname');\n      alert(message.message);\n      this.init();\n      return;\n    }\n    console.log('Успешная авторизация');\n  }\n\n  updateUserList(users) {\n    this.usersList.innerHTML = users\n      .map((user) => createUserElement(user, user === this.nickname))\n      .join('');\n  }\n\n  addMessage({ from, text, timestamp }) {\n    this.messagesList.insertAdjacentHTML(\n      'beforeend',\n      createMessageElement(from, text, timestamp, from === this.nickname),\n    );\n    this.messagesList.scrollTop = this.messagesList.scrollHeight;\n  }\n}\n"],"names":["WebSocketClient","constructor","this","url","ws","handlers","Map","reconnectAttempts","maxReconnectAttempts","connect","console","log","WebSocket","waitForConnection","bindEvents","error","handleReconnect","timeout","Math","min","pow","Promise","resolve","setTimeout","reject","Error","onopen","clearTimeout","onerror","onclose","onmessage","handleMessage","bind","on","type","callback","set","send","message","readyState","OPEN","JSON","stringify","login","nickname","sendMessage","text","close","escapeHtml","div","document","createElement","textContent","innerHTML","client","localStorage","getItem","messagesList","getElementById","usersList","messageForm","messageInput","init","promptNickname","setItem","initWebSocket","removeItem","prompt","trim","setupWebSocketHandlers","handleLogin","updateUserList","addMessage","addEventListener","handleSubmit","event","preventDefault","value","success","alert","users","map","user","isCurrentUser","createUserElement","join","from","timestamp","insertAdjacentHTML","isOwn","time","Date","toLocaleTimeString","createMessageElement","scrollTop","scrollHeight"],"sourceRoot":""}